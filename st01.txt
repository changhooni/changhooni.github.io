cs50.ai
사이트는 누가나 사용이 가능한가?

128 64 32 16 8 4 2 1
 0   0  0  0 0 0 0 0
ASCII 값을 계산하는 방법 하는 비트에 1로 이루어진 경우 해당하는 비트값을 더하여 
ASCII 값을 확인 할 수 있음
ASCII표를 확인하는 해당하는 숫자에 문자 및 기호를 확인 할 수 있음

한글에 ASCII 값은 어떻게 계산하는가?
ASCII코드로 설정된 부분이 아니라 unicode값이로 매칭된 문자를 출력
2바이트 사용(16진수)

Scratch
scratch.mit.edu 사이트
input -> algorithnm -> output
프로그래밍을 쉽게 접근하고 사용자 친화적

프로그래밍 언어를 어떻게 해서 컴퓨터에서는 해석하는건가?
소스를 변환해주는 기계적은 방법을 무엇이라고 하는가?
source code -> compiler(기계어로 변환) -> machine code

cs50.dev 사이트 무료로 사용가능 (github 사용자)

vscode 
그래픽컬 유저 인터페이지(아이콘, 메, 버튼 등등,GUI)
vscode 터미널
개념적으로 command line interface
명령어 인터페이스(CLI)
make, clang -> 코드의 컴파일을 트리거
clang -o hello hello.c -> hello.c 파일을 clang 명령어 인수자 -o를 넣어서 hello라는 컴파일 파일을 만듬

강의에서 hello로 make를 했는데 실행시에는 ./hello로 실행을 하는 이유는 무언인가?
./ -> 경로는 지정하는 부분이라서 실제 hello라는 make로 만들어 파일이 어는 위치에 있는
확인하고 그 위에 파일이 있으면 실행 없으면 실행이 되지 않는다.
왜 ./hello로 실행을 해야 하는가?
컴파일러가 해당하는 소스코드를 기계어로 변환을 해야 사용이 가능 하기 때문
왜 ./hello.c를 실행하지 않는가?
c언어는 컴파일을 사용하여 기계어를 변환을 해야 하므로 소스코드를 바로 사용을 하면
오류를 발생하며 실행도 되지 않는데 
컴파일을 사용하지 않는 언어는 해당 언어에 가상컴파일러 포함이 되어 있어서 자동으로 컴파일을
진행하고 실행을 한다

.h(표준 io.h)로 끝나는 모든 파일은 소스가 아닙니다(헤더파일)
소스코드 상단에 헤더파일이 없으면 오류 발생
소스코드 상단에 있는거는 일종에 도서관이라고 생각하며 이는 라이브러리(libraries)함

libraries(라이브러리) 다른 사람이 작성한 코드 모음

manual.cs50.io 사이트 C에서 사용하는 함수를 확인할 수 있음
해당하는 사이트에는 표준 io.h에 사용된 라이브러리를 확인 및 관련 내용 설명도 제공

cs50 강의에서 사용하는 cs50.h 헤더파일은 어떻게 사용할 수 있는건가?
정확히는 헤더파일을 설치가 필요한 부분인가?

C, C++, java 
counter =  counter + 1; -> counter += 1; -> counter++;
1씩 증가하는 방법 세가지


C 강의
compare.c 내용중에 int x = get_int("내용") 여기에서 int로 타입을 선언을 했는데 
하고 get_int 라이브러리를 사용하였는데 int로 타입을 선언을 하면 숫자로 인식을 해야 하는거 
아닌가? 그럼 실행 시 오류가 나와야 하는건 아닌지?
get_int 이라는 라이브러리에 input 으로 등록하는 부분이 있으면 등록된 부분에 숫자를 
입력을 하면 x = 숫자로 지정이 되기 때문에 해당하는 부분에서는 오류가 발생하지 않는다.


프로그래밍을 중요성 3가지
정확성, 디자인(프로그래밍의 코드를 더 잘 구성할 수 있는지), 스타일(보기 편하게)
check50, desing50, style50

constants
cont i = 9;
고정된 값으로 지정이 됨
i값을 다시 지정을 해도 컴파일러가 변경을 허용하지 않음


overflow
지정된 메모니를 넣어가면 그 부분부터 음수로 갔다가 0으로 지정됨

truncation
소주점는 모두 짜른다 -> 값에 타입을 float로 변경하면 소수점이 처리됨

int, float 32비트 메모리를 사용 더 많은 숫자를 사용할려면 long, double float를 사용

preprocessing -> 소스에서 사용하는 라이브러리나 프로토타입을 전처리함 
compiling -> 소스코드를 읽을 수 있도록 변환
assembling -> 변환된 소스코드를 기계어로 처리 
linking -> 소스코드에 있는 전처리파일과 코드작성 파일을 하나로 연결


string 타입은 실제 메모리에는 문자길이+1로 지정이 된다.
마지막를 나타내는 부분은 0으로 처리한다
0부분으로 처리되는 부분은 NUL이라고 하고 문자에 종료를 의미한다
manual.cs50.io/#string.h 메뉴얼에서 문자열에 대한 함수들을 확인할 수 있다

대소문자 변환에서 문자열을 연산할 수 있는 이유는?
지정된 문자열에 ASCII 값으로 컴퓨터는 처리 하기 때문에 문자열에 마이너스 연산이 가능하기 처리된다

int main(int argc(#인수갯수), string argv[](#인수 갯수 배열))

선택정렬, 버블정렬 알고리즘? 더욱 디테일한 설명이 필요

재귀 알고리즘 
자기 자신을 호출하는 것(재귀 함수)

병렬정렬
데이터를 반으로 나누거 왼쪽 오른쪽 
왼쪽 데이터를 다시 반으로 나누고 왼쪽 정렬
나머지 오른쪽 데이터 정렬
왼쪽, 오른쪽 정렬된 데이터를 다시 합치고 정렬

malloc?
node?

Hexadecimal(16진수)
0 1 2 3 4 5 6 7 8 9 A B C D E F로 정의 두자리 숫자는 문자로 정의(A B C D E F)
00 값이 01, 02, 03... 으로 계속 올라가면 가장 마지막 값을 FF가 되며 
이 00 ~ FF 까지 값을 0 ~ 255로 됨
00 -> 4비트, 0000 -> 8비트, 0000 0000 -> 16비트
0x0, 0x1, 0x2... 0xF -> 중간에 x를 넣어서 메모리에 바이트 상자를 표현한다
pointer(포인터) -> 무언가의 주소를 저장하는 변수

FIFO
queues -> 대기줄
enqueue -> 대기열에 넣는다
dequeue -> 대기열에서 꺼낸다

LIFO
push -> 스택 맨 위에 무언가를 푸시하는 작업
pop -> 스택 맨 위에서 무언가를 제거하는 작업

linked lists -> 컴퓨터 메모리에 있는 것들을 연결하기 위해 포인터를 사용하는 리스트

trees
-> 매우 흔한 데이터 구조, 2차원 배열 구조

binary search trees
-> 이진 탐색 트리
-> 이전 탐색을 수행하고 실행 시간에 n의 로그 밑 2를 달성할 수 있다고 하더라도
실제로 균형을 유지하도록 보장하기 위해 어느 정도 노력을 기울여야 한다는 것

2차원 배열 트리
-> 유연성과 역동성을 얻었음에도 불구하고 연결 리스트에서 이진 검색을 수행할 수 없는
이유는 거꾸로 돌아갈 수 없는 긴 문자열 형태의 데이터 구조가 있기 때문에

dictionaries(디셕러니)
-> 목록, 배열 트리를 넘어 코드에서 단어와 정의를 연관시키는 기능까지 갖춘 놀라울 정도
유용한 데이터 구조
-> key, value를 연결하여 사용하는 구조

hashing
-> hash function(해시함수) 어떤 값이 메모리의 어디에 위치하는지 결정할 수 있게 해줌
-> 어떤 값을 입력 받아서 다른 값을 출력 받음 이런 작업을 하는 수학이나 코드임

hash tables
-> 입력과 출력으로 생성하는 코드나 수학 함수를 사용하면 hash tables를 만들 수 있음

tries
-> 데이터를 검색하기 위한 데이터 구조
-> key-value 쌍을 구현할 수 있는 대체 데이터 구조
-> 배열, 연결 리스트, 해시테이블, 트라이로 사전을 구현할 수 있습니다.

python 
-> docs.python.org
-> 매개변수(define)로 정의된 것은 함수를 실행하는 부분이 존재하여야 한다
-> isnumeric() 숫자여부를 확인하는 내장함수

API(애플리케이션 프로그래밍 인터페이지)


프롬프트 엔지니어링(system prompt)
-> 어딘가의 누군가가 AI를 위해 시스템 프롬프트를 작성했다는 것을 의미

cs50.edx.org
수업강의 사이트




pccp 코딩 테스트 연습문제
https://school.programmers.co.kr/learn/courses/30/lessons/181950?language=python3

### 현재 방식을 완성하기 위해 필요한 공부

#### **핵심 학습 포인트: `str.join()` 메소드**
join() 은 문자열 메소드로, 리스트나 튜플 같은 반복 가능한(iterable) 객체의 요소들을 하나의 문자열로 합쳐주는 메소드

'''python
my_list = ['hello', 'hello', 'hello']
result = "".join(my_list)
print(result)
# 출력: "hellohellohello"
'''

### 더 효율적이고 "파이썬스러운" 방법

#### **핵심 학습 포인트: 문자열 곱셈 연산자 (`*`)**
파이썬에서는 문자열에 정수를 곱할 수 있습니다. 이는 해당 문자열을 정수만큼 반복하는 효과를 가집니다.

'''python
str = "abc"
n = 3
result = str * n
print(result)
# 출력: "abcabcabc"
'''

1.  **파이썬 기본 자료형(Data Types) 특징 완벽히 이해하기**
    *   **문자열(String):** 문자열끼리 더하기(`+`), 곱하기(`*`)가 가능하다는 특징을 학습하세요.
    *   **리스트(List):** 여러 데이터를 담는 '그릇'이라는 점, `append()`로 요소를 추가하는 방법 등을 복습하세요.
    *   **자료형 변환:** `int()`처럼 문자열을 숫자로 바꾸거나, 리스트를 문자열로 바꾸는(`join`) 등의 변환 방법을 익히는 것이 중요합니다.

2.  **문자열 메소드(String Methods) 깊게 파고들기**
    *   **`join()`:** 리스트를 문자열로 합칠 때 필수적이고 매우 효율적인 방법입니다.
    *   **`split()`:** 이미 사용하셨지만, 특정 문자를 기준으로 문자열을 나누어 리스트로 만드는 강력한 도구입니다.
    *   **`strip()`:** 양쪽 공백 제거, `lstrip()`, `rstrip()` 등 파생 메소드도 함께 알아두면 좋습니다.
    *   `replace()`, `find()`, `upper()`, `lower()` 등 다른 유용한 문자열 메소드도 많으니 꼭 살펴보세요.

3.  **"파이썬스러운 코드(Pythonic Code)" 작성법 익히기**
    *   파이썬은 다른 언어에 비해 간결하고 직관적인 문법을 많이 제공합니다.
    *   문자열 곱셈(`*`)이나, 나중에 배우게 될 **리스트 컴프리헨션(List Comprehension)** 같은 기능들을 익히면 코드가 짧아지고 가독성이 높아집니다.
    *   단순히 동작하는 코드를 넘어, "어떻게 하면 더 효율적이고 보기 좋게 짤 수 있을까?"를 항상 고민하는 습관을 들이면 실력이 빠르게 향상될 것입니다.

'''python
str, n = input().strip().split(' ')
n = int(n)
su = len(str)
answer = 0
s = str
if 1 <= su <= 10 and 1 <= n <= 5:
        answer = [s for _ in range(n)]
        answer = ''.join(answer)
else:
    answer = '최대값을 넘었습니다.'

print(answer)
'''



https://school.programmers.co.kr/learn/courses/30/lessons/181949?language=python3
### 핵심 학습 포인트 (이것만 알면 됩니다!)

1.  **문자열 순회 (Iteration)**: 문자열에 포함된 각 문자를 하나씩 처음부터 끝까지 살펴보는 방법.
2.  **조건문 (Conditional Statement)**: 특정 조건(예: '이 문자가 대문자인가?')에 따라 다른 코드를 실행하는 방법.
3.  **대소문자 판별 함수**: 현재 문자가 대문자인지 소문자인지 확인하는 기능.
4.  **대소문자 변환 함수**: 문자를 대문자에서 소문자로, 또는 소문자에서 대문자로 바꾸는 기능.

---

### 1. 문자열 순회 (하나씩 꺼내보기)

문자열 `str`이 "aBcDe" 라면, 'a', 'B', 'c', 'D', 'e'를 하나씩 차례대로 꺼내서 작업을 해야 합니다. 이때 `for` 반복문이 가장 흔하게 사용됩니다.

**예시 (Python):**
```python
str = "aBcDe"
for char in str:
    print(char) # char 변수에 'a', 'B', 'c', 'D', 'e'가 차례로 할당됩니다.
```

### 2. 조건문 (경우에 따라 다르게 행동하기)

꺼내온 문자가 대문자인 경우와 소문자인 경우에 해야 할 일이 다릅니다. 이처럼 조건에 따라 코드를 분기할 때 `if`, `elif`, `else`를 사용합니다.

*   **if**: 만약 이 문자가 대문자라면?
*   **elif**: (대문자가 아니고) 만약 이 문자가 소문자라면?
*   **else**: 둘 다 아니라면? (이 문제에서는 알파벳만 다루므로 `else`는 `elif`로 충분합니다.)

### 3. 대소문자 판별 (정체 파악하기)

프로그래밍 언어는 문자가 대문자인지 소문자인지 쉽게 확인할 수 있는 기능을 제공합니다.

*   `islower()`: 소문자인지 확인 (맞으면 True, 아니면 False)
*   `isupper()`: 대문자인지 확인 (맞으면 True, 아니면 False)

**예시 (Python):**
```python
char1 = 'a'
char2 = 'B'

print(char1.islower()) # True 출력
print(char2.islower()) # False 출력

print(char1.isupper()) # False 출력
print(char2.isupper()) # True 출력
```

### 4. 대소문자 변환 (모습 바꾸기)

판별이 끝났으면 이제 변환을 해야 합니다. 이 또한 간단한 함수로 제공됩니다.

*   `lower()`: 모든 문자를 소문자로 변경
*   `upper()`: 모든 문자를 대문자로 변경

**예시 (Python):**
```python
char1 = 'a'
char2 = 'B'

print(char1.upper()) # 'A' 출력
print(char2.lower()) # 'b' 출력
```

---

### 종합: 문제 해결 과정

위 4가지 개념을 조합하면 문제를 다음과 같은 순서로 해결할 수 있습니다.

1.  결과를 저장할 빈 문자열을 하나 만든다. (예: `result = ""`)
2.  주어진 문자열 `str`의 문자를 **하나씩 순회한다.** ( `for` 반복문 사용)
3.  **만약** 현재 문자가 **소문자라면**, **대문자로 변환**해서 결과 문자열에 추가한다.
4.  **그렇지 않고 만약** 현재 문자가 **대문자라면**, **소문자로 변환**해서 결과 문자열에 추가한다.
5.  반복이 끝나면, 완성된 결과 문자열을 출력한다.

### 실제 코드 예시 (Python)

```python
str = "aBcDeFg"
result = "" # 1. 결과를 저장할 빈 문자열

# 2. str의 각 문자를 char라는 변수로 순회
for char in str:
    # 3. 만약 char가 소문자이면?
    if char.islower():
        # 대문자로 바꿔서 result에 이어붙이기
        result += char.upper()
    # 4. 그렇지 않고 만약 char가 대문자이면?
    elif char.isupper():
        # 소문자로 바꿔서 result에 이어붙이기
        result += char.lower()

# 5. 최종 결과 출력
print(result) # "AbCdEfG"가 출력됩니다.
```

### 심화 학습: 컴퓨터는 문자를 어떻게 이해할까요? (ASCII 코드)

조금 더 깊이 들어가면, 컴퓨터는 사실 'a'나 'A' 같은 문자를 직접 저장하지 않고 숫자로 바꿔서 저장합니다. 이 규칙을 **ASCII(아스키) 코드**라고 합니다.

*   'A'는 숫자 65
*   'B'는 숫자 66
*   ...
*   'a'는 숫자 97
*   'b'는 숫자 98

흥미롭게도, 모든 알파벳의 대문자와 소문자는 숫자 **32**만큼 차이가 납니다.
(예: 'a'(97) - 'A'(65) = 32)

그래서 과거에는 문자를 숫자로 바꾼 뒤 32를 더하거나 빼서 대소문자를 변환하기도 했습니다. 하지만 지금은 위에서 설명한 `upper()`, `lower()` 같은 내장 함수를 쓰는 것이 훨씬 안전하고 코드를 읽기에도 좋습니다.

**결론적으로, `for`, `if`, `isupper()`, `islower()`, `upper()`, `lower()` 이 개념들을 중심으로 공부하시면 이 문제를 완벽하게 이해하고 해결하실 수 있습니다!**


'''python
str = input()
str_arr = []
for char in str:
    if char.islower():
        str_arr.append(char.upper())
    else:
        str_arr.append(char.lower())

str_arr = ''.join(str_arr)
print(str_arr)

print(input().swapcase())
'''