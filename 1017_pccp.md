'[정수를 나선형으로 배치하기](https://school.programmers.co.kr/learn/courses/30/lessons/181832?language=python3)'

안녕하세요! 이 문제는 '나선형 배열(Spiral Matrix)' 만들기라고 불리는 클래식한 코딩 테스트 문제입니다. 이 문제를 해결하기 위해 알아야 할 내용들을 단계별로 알기 쉽게 설명해 드릴게요.

문제를 풀기 위해 필요한 핵심 아이디어는 **"현재 위치"**와 **"진행 방향"**을 변수로 관리하고, **"방향을 바꿔야 할 조건"**을 명확히 정의하는 것입니다.

---

### 알아야 할 내용 (필요 지식)

#### 1. 2차원 배열(리스트) 생성 및 사용법 (파이썬)

먼저, 결과를 담을 `n x n` 크기의 2차원 배열을 만들어야 합니다. 모든 값을 0으로 초기화해두면, 아직 숫자를 채우지 않은 칸을 쉽게 식별할 수 있습니다.

**올바른 2차원 배열 생성법:**

```python
n = 4
# 각 행(row)이 독립적인 객체로 생성됩니다.
answer = [[0] * n for _ in range(n)] 
```
이 코드는 `[0, 0, 0, 0]` 이라는 리스트를 `n`번 생성하여 `n x n` 배열을 만듭니다.

**주의! 잘못된 방법:**
`[[0] * n] * n` 과 같이 만들면 내부 리스트가 모두 동일한 객체를 참조하게 되어, 한 곳의 값을 바꾸면 다른 행의 값도 같이 바뀌는 문제가 발생합니다.

#### 2. 상태를 추적하기 위한 변수 관리

나선형으로 움직이는 과정을 시뮬레이션하기 위해 다음 상태들을 변수로 계속 추적해야 합니다.

*   **현재 숫자**: 배열에 채워 넣을 숫자 (1부터 `n*n`까지 증가)
*   **현재 위치 (행, 렬)**: 현재 숫자를 채워 넣을 배열의 인덱스 `(row, col)`
*   **현재 진행 방향**: 오른쪽, 아래, 왼쪽, 위 중 어느 방향으로 가고 있는지

#### 3. 방향 제어 로직 (가장 중요!)

컴퓨터는 '나선형'을 직접 이해하지 못합니다. 따라서 우리는 '직진하다가 벽을 만나면 시계방향으로 90도 꺾는다'는 규칙을 코드로 구현해야 합니다.

**방법 1: 방향 벡터 사용**

가장 일반적이고 효율적인 방법입니다.

*   **방향 정의**: 방향을 4개(오른쪽, 아래, 왼쪽, 위)로 정의하고, 각 방향에 대한 행/열의 변화량을 미리 만들어 둡니다.
    *   오른쪽: 행 변화 `0`, 열 변화 `+1`
    *   아래쪽: 행 변화 `+1`, 열 변화 `0`
    *   왼쪽: 행 변화 `0`, 열 변화 `-1`
    *   위쪽: 행 변화 `-1`, 열 변화 `0`

*   **코드로 구현**:
    ```python
    # 행(row)의 변화량: 아래, 왼쪽, 위 순서
    dr = [0, 1, 0, -1] 
    # 열(col)의 변화량: 오른쪽, 아래, 왼쪽, 위 순서
    dc = [1, 0, -1, 0] 
    
    # 현재 방향을 가리키는 인덱스 (0:오른쪽, 1:아래, 2:왼쪽, 3:위)
    direction = 0 
    ```
    이제 다음 위치는 `current_r + dr[direction]`, `current_c + dc[direction]` 으로 간단하게 계산할 수 있습니다.

*   **방향 전환**: 현재 방향에서 시계방향으로 90도 꺾는 것은 `direction` 인덱스를 1 증가시키는 것과 같습니다.
    ```python
    # 0 -> 1 -> 2 -> 3 -> 0 ... 순환
    direction = (direction + 1) % 4 
    ```
    `% 4` 연산을 통해 `direction` 값이 3을 넘어가면 다시 0이 되도록 만듭니다.

#### 4. 방향 전환 조건 정의

언제 방향을 바꿔야 할까요? 다음 두 가지 경우입니다.

1.  **배열의 경계를 벗어날 때**: 다음에 이동할 위치가 `0`보다 작거나 `n-1`보다 클 때.
2.  **이미 숫자가 채워진 칸을 만났을 때**: 다음에 이동할 위치의 값이 `0`이 아닐 때 (이미 방문했다는 의미).

---

### 문제 해결 로직 (단계별 구현)

위 지식들을 종합하여 실제 코드를 짜는 순서는 다음과 같습니다.

**1단계: 초기화**

*   `n x n` 크기의 2차원 배열을 0으로 초기화합니다.
*   현재 위치 `(r, c)`를 시작점인 `(0, 0)`으로 설정합니다.
*   채워 넣을 숫자 `num`을 1로 설정합니다.
*   방향 벡터 `dr`, `dc`를 정의하고, 현재 방향 `direction`을 0(오른쪽)으로 설정합니다.

**2단계: 반복문 실행**

*   `num`이 1부터 `n*n`까지 변하는 동안 반복합니다. (`for num in range(1, n*n + 1):`)

**3단계: 반복문 내부 로직**

1.  **숫자 채우기**: 현재 위치 `(r, c)`에 현재 숫자 `num`을 할당합니다. `answer[r][c] = num`
2.  **다음 위치 계산**: `nr = r + dr[direction]`, `nc = c + dc[direction]`
3.  **방향 전환 검사**: 다음 위치 `(nr, nc)`가 유효한지 검사합니다.
    *   `if nr < 0 or nr >= n or nc < 0 or nc >= n or answer[nr][nc] != 0:`
    *   위 조건이 참이라면, 방향을 바꿔야 합니다.
4.  **방향 전환**: `direction = (direction + 1) % 4`
5.  **현재 위치 업데이트**: **새로운 방향**에 따라 현재 위치 `(r, c)`를 업데이트합니다.
    *   `r += dr[direction]`
    *   `c += dc[direction]`
6.  반복문이 끝나면 `answer`를 반환합니다.

**잠깐! 위치 업데이트 시점**
위 3~5번 로직을 잘 보세요. 숫자를 먼저 채우고, **다음 이동을 위해** 위치를 업데이트합니다.

초보자가 하기 쉬운 실수는 `if` 문 바깥에서 `r, c`를 업데이트하는 것입니다. 그렇게 하면 방향을 바꾼 후, **바뀐 방향으로 바로 한 칸 이동**하게 되어 원하는 결과가 나옵니다.

좀 더 직관적인 코드는 다음과 같습니다.

'''python
def solution(n):
    """
    n x n 배열에 1부터 n^2까지 정수를 시계방향 나선형으로 배치합니다.

    Args:
        n: 배열의 크기 (양의 정수)

    Returns:
        n x n 크기의 2차원 배열 (리스트)
    """
    # 1. n x n 크기의 2차원 배열을 0으로 초기화합니다.
    #    각 행이 독립적인 리스트가 되도록 [[0] * n for _ in range(n)] 방식을 사용합니다.
    answer = [[0] * n for _ in range(n)]

    # 2. 현재 위치 (행, 열)를 초기화합니다. 시작은 [0][0]입니다.
    r, c = 0, 0

    # 3. 현재 채워 넣을 숫자를 초기화합니다. 1부터 시작합니다.
    num = 1

    # 4. 방향을 정의합니다.
    #    dr: 행(row)의 변화량 (오른쪽, 아래, 왼쪽, 위)
    #    dc: 열(col)의 변화량 (오른쪽, 아래, 왼쪽, 위)
    #    순서: 0: 오른쪽, 1: 아래, 2: 왼쪽, 3: 위
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]

    # 5. 현재 진행 방향을 나타내는 인덱스 (0: 오른쪽)
    direction = 0

    # 6. 1부터 n*n까지 숫자를 채워 넣기 위한 반복문
    while num <= n * n:
        # 현재 위치에 숫자 채우기
        answer[r][c] = num
        num += 1 # 다음 숫자로 증가

        # 다음 이동할 위치 계산
        next_r = r + dr[direction]
        next_c = c + dc[direction]

        # 다음 위치가 유효한지 검사
        # 조건:
        # 1. 배열의 경계를 벗어나지 않는가 (0 <= next_r < n and 0 <= next_c < n)
        # 2. 이미 숫자가 채워진 칸이 아닌가 (answer[next_r][next_c] == 0)
        if 0 <= next_r < n and 0 <= next_c < n and answer[next_r][next_c] == 0:
            # 유효하면, 다음 위치로 이동
            r, c = next_r, next_c
        else:
            # 유효하지 않으면, 방향을 바꿉니다.
            # direction을 1 증가시키고, 4로 나눈 나머지를 취해 0, 1, 2, 3을 순환합니다.
            direction = (direction + 1) % 4
            # 바뀐 방향으로 한 칸 이동합니다.
            r = r + dr[direction]
            c = c + dc[direction]

    return answer

```python
def solution(n):
    answer = [[0] * n for _ in range(n)]
    r, c = 0, 0
    num = 1
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    direction = 0
    
    while num <= n * n:
        answer[r][c] = num
        num += 1
        
        next_r = r + dr[direction]
        next_c = c + dc[direction]
        
        if 0 <= next_r < n and 0 <= next_c < n and answer[next_r][next_c] == 0:
            r, c = next_r, next_c
        else:
            direction = (direction + 1) % 4
            r = r + dr[direction]
            c = c + dc[direction]
            
                
    return answer
```

'[평행](https://school.programmers.co.kr/learn/courses/30/lessons/120875?language=python3)'


안녕하세요! 주어진 문제를 파이썬으로 해결하기 위해 알아야 할 핵심 개념들을 단계별로 알기 쉽게 설명해 드리겠습니다.

### 알아야 할 내용 요약

1.  **핵심 수학 개념**: 두 직선이 평행하려면 **기울기(slope)**가 같아야 합니다.
2.  **문제 해결 전략**: 네 개의 점으로 만들 수 있는 **모든 직선 쌍의 조합**을 찾아내고, 각 쌍의 기울기를 비교합니다.
3.  **파이썬 구현 기술**:
    *   2차원 리스트(배열)의 원소에 접근하는 방법
    *   기울기를 계산하는 사칙연산
    *   조합에 따른 경우를 모두 확인하기 위한 조건문 (`if`)

---

### 1. 핵심 수학 개념: 기울기 (Slope)

두 점 `(x1, y1)`과 `(x2, y2)`를 잇는 직선의 기울기는 다음과 같이 계산합니다.

> **기울기 = (y값의 변화량) / (x값의 변화량) = (y2 - y1) / (x2 - x1)**

문제에서 두 직선이 평행하다고 했으므로, 우리가 만들어낼 두 직선의 기울기가 같은지 확인하면 됩니다.

예를 들어, 점 `[1, 4]`와 `[3, 8]`을 잇는 직선의 기울기는:
*   `(8 - 4) / (3 - 1) = 4 / 2 = 2`

점 `[9, 2]`와 `[11, 6]`를 잇는 직선의 기울기는:
*   `(6 - 2) / (11 - 9) = 4 / 2 = 2`

두 기울기가 `2`로 같으므로, 이 두 직선은 평행합니다.

### 2. 문제 해결 전략: 모든 경우의 수 확인하기

네 개의 점(A, B, C, D)이 주어졌을 때, 두 개씩 짝을 지어 두 개의 직선을 만드는 경우는 총 3가지입니다.

*   **경우 1**: (A, B를 잇는 직선) vs (C, D를 잇는 직선)
*   **경우 2**: (A, C를 잇는 직선) vs (B, D를 잇는 직선)
*   **경우 3**: (A, D를 잇는 직선) vs (B, C를 잇는 직선)

이 세 가지 경우 중 **단 하나라도** 두 직선의 기울기가 같다면, 평행한 경우가 존재하는 것이므로 `1`을 반환하면 됩니다. 세 가지 경우 모두 기울기가 다르다면, 평행한 경우가 없는 것이므로 `0`을 반환합니다.

### 3. 파이썬으로 구현하기 위해 알아야 할 것들

#### 가. 2차원 리스트 원소 접근하기

`dots`는 `[[x1, y1], [x2, y2], ...]` 형태의 리스트입니다. 각 점의 좌표에 접근하는 방법은 다음과 같습니다.

```python
dots = [[1, 4], [9, 2], [3, 8], [11, 6]]

# 첫 번째 점 (A)
p1 = dots[0]  # [1, 4]
x1 = dots[0][0] # 1
y1 = dots[0][1] # 4

# 두 번째 점 (B)
p2 = dots[1]  # [9, 2]
x2 = dots[1][0] # 9
y2 = dots[1][1] # 2

# 이런 식으로 모든 점에 접근할 수 있습니다.
p3 = dots[2]
p4 = dots[3]
```

#### 나. 기울기 계산 함수 만들기 (선택 사항이지만 추천)

코드를 깔끔하게 만들기 위해, 두 점을 입력받아 기울기를 계산해주는 함수를 만드는 것이 좋습니다.

```python
def get_slope(p1, p2):
    # p1은 [x1, y1], p2는 [x2, y2] 형태의 리스트
    # 기울기 = (y2 - y1) / (x2 - x1)
    return (p2[1] - p1[1]) / (p2[0] - p1[0])
```

#### 다. 세 가지 경우를 모두 확인하는 조건문 작성하기

이제 위에서 설명한 세 가지 경우의 수에 대해 각각 기울기를 계산하고 비교합니다.

```python
def solution(dots):
    # 각 점을 변수에 할당하면 코드가 더 읽기 쉬워집니다.
    p1, p2, p3, p4 = dots[0], dots[1], dots[2], dots[3]

    # 경우 1: (p1, p2) 직선과 (p3, p4) 직선의 기울기 비교
    slope1 = get_slope(p1, p2)
    slope2 = get_slope(p3, p4)
    if slope1 == slope2:
        return 1

    # 경우 2: (p1, p3) 직선과 (p2, p4) 직선의 기울기 비교
    slope3 = get_slope(p1, p3)
    slope4 = get_slope(p2, p4)
    if slope3 == slope4:
        return 1

    # 경우 3: (p1, p4) 직선과 (p2, p3) 직선의 기울기 비교
    slope5 = get_slope(p1, p4)
    slope6 = get_slope(p2, p3)
    if slope5 == slope6:
        return 1

    # 위 세 경우에 모두 해당하지 않으면 평행한 경우가 없는 것
    return 0

# 위 코드를 실행하기 위한 get_slope 함수
def get_slope(p1, p2):
    return (p2[1] - p1[1]) / (p2[0] - p1[0])
```

### ※ 전문가 팁: 부동소수점 오차 피하기

컴퓨터에서 나눗셈을 하면 `0.3333...` 와 같은 무한소수나 미세한 계산 오차가 발생할 수 있습니다. 이런 오차 때문에 `==` 비교가 실패할 수도 있습니다.

이것을 피하는 더 안정적인 방법은 나눗셈 대신 곱셈을 이용하는 것입니다.

`a / b == c / d` 라는 수식은 양변에 `b * d` 를 곱하여 `a * d == c * b` 로 바꿀 수 있습니다.

이를 기울기 계산에 적용하면 다음과 같습니다.
`(y2 - y1) / (x2 - x1) == (y4 - y3) / (x4 - x3)`
  ↓ (교차 곱셈)
`(y2 - y1) * (x4 - x3) == (y4 - y3) * (x2 - x1)`

이렇게 하면 나눗셈 없이 정수의 곱셈만으로 비교할 수 있어 훨씬 정확하고 안전합니다.

#### 개선된 코드 예시

```python
def solution(dots):
    # 경우 1: ([0],[1]) vs ([2],[3])
    # (y1-y0)*(x3-x2) == (y3-y2)*(x1-x0)
    if (dots[1][1] - dots[0][1]) * (dots[3][0] - dots[2][0]) == (dots[3][1] - dots[2][1]) * (dots[1][0] - dots[0][0]):
        return 1
        
    # 경우 2: ([0],[2]) vs ([1],[3])
    if (dots[2][1] - dots[0][1]) * (dots[3][0] - dots[1][0]) == (dots[3][1] - dots[1][1]) * (dots[2][0] - dots[0][0]):
        return 1

    # 경우 3: ([0],[3]) vs ([1],[2])
    if (dots[3][1] - dots[0][1]) * (dots[2][0] - dots[1][0]) == (dots[2][1] - dots[1][1]) * (dots[3][0] - dots[0][0]):
        return 1

    return 0
```

이 내용을 바탕으로 파이썬 코드를 작성하시면 문제를 해결하실 수 있을 겁니다


```python
def get_slope(k1, k2):
    return (k2[1] - k1[1]) * (k2[0] - k1[0])
def solution(dots):
    answer = 0
    p1, p2, p3, p4 = dots[0], dots[1], dots[2], dots[3]
    
    s1 = get_slope(p1, p2)
    s2 = get_slope(p3, p4)
    if s1 == s2:
        answer = 1
        
    s3 = get_slope(p1, p3)
    s4 = get_slope(p2, p4)
    if s3 == s4:
        answer = 1
    
    s5 = get_slope(p1, p4)
    s6 = get_slope(p2, p3)
    if s5 == s6:
        answer = 1
        
    return answer    #진행중 통과가 안되는 부분이 발생 왜 안되는지 정확하게 모르겠음.
```