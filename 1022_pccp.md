# Gemini 2.5 Pro
이 문제를 풀기 위해서는 여러 데이터를 효율적으로 저장하고, 조회하고, 계산하는 능력이 필요합니다. 다음과 같은 파이썬 개념들을 공부하시면 큰 도움이 될 것입니다.

### 1. 딕셔너리 (Dictionary)

**왜 필요한가요?**
이 문제의 핵심은 **"누가", "누구를", "몇 번"** 신고했는지와 같은 관계 및 횟수 정보를 관리하는 것입니다. 딕셔너리는 `Key: Value` 쌍으로 데이터를 저장하기 때문에 이런 정보를 다루기에 가장 적합한 자료구조입니다.

*   **사용 예시 1: 유저별 신고당한 횟수 기록**
    *   `Key`를 '신고당한 유저 ID'로, `Value`를 '신고당한 횟수'로 설정하여 관리할 수 있습니다.
    *   예: `{'frodo': 2, 'neo': 2, 'muzi': 1}` 와 같이 각 유저가 몇 번 신고당했는지 쉽게 저장하고 업데이트할 수 있습니다.

*   **사용 예시 2: 유저가 신고한 다른 유저 목록 관리**
    *   `Key`를 '신고한 유저 ID'로, `Value`를 '그 유저가 신고한 ID 목록(리스트)'으로 설정할 수 있습니다.
    *   예: `{'muzi': ['frodo', 'neo'], 'apeach': ['frodo', 'muzi'], ...}` 와 같이 누가 누구를 신고했는지 관계를 명확하게 저장할 수 있습니다.

*   **사용 예시 3: 각 유저가 받을 메일 수 계산**
    *   `Key`를 '유저 ID'로, `Value`를 '받을 메일 수'로 설정하여 최종 결과를 계산하는 데 사용할 수 있습니다.
    *   처음에는 모든 유저의 메일 수를 0으로 초기화해두고, 조건에 맞을 때마다 1씩 증가시키는 방식으로 활용합니다.

### 2. 세트 (Set)

**왜 필요한가요?**
문제 설명에 **"동일한 유저에 대한 신고 횟수는 1회로 처리됩니다"** 라는 중요한 조건이 있습니다. 즉, 중복 신고는 무시해야 합니다. 세트(Set)는 중복된 원소를 허용하지 않는 자료구조이므로 이 조건을 간단하게 처리할 수 있습니다.

*   **사용 예시: 중복 신고 제거**
    *   `report` 배열에 있는 "muzi frodo"가 여러 번 들어오더라도, 세트에 `("muzi", "frodo")` 라는 튜플 형태로 저장하면 중복이 자동으로 제거됩니다.
    *   이렇게 한 번 정제된 데이터를 사용하면 이후 로직을 훨씬 간단하게 만들 수 있습니다.

### 3. 문자열 처리 (String Manipulation) - `split()` 메소드

**왜 필요한가요?**
`report` 배열의 각 원소는 "muzi frodo"와 같이 "신고한유저 신고당한유저" 형식의 하나의 문자열로 되어 있습니다. 이 문자열에서 두 유저의 ID를 분리해내야 합니다.

*   **사용 예시: 신고자와 피신고자 분리**
    *   `"muzi frodo".split(' ')` 를 사용하면 공백을 기준으로 문자열을 나눠 `['muzi', 'frodo']` 라는 리스트를 얻을 수 있습니다.
    *   이 결과를 이용해 누가 신고했고 누가 신고당했는지 파악할 수 있습니다.

### 4. 반복문 (For Loops)

**왜 필요한가요?**
`id_list`나 `report` 같은 리스트(배열)의 모든 원소를 하나씩 확인하거나, 딕셔너리의 모든 `Key`와 `Value`를 순회하며 작업을 처리해야 합니다.

*   **사용 예시:**
    *   `report` 배열의 모든 신고 기록을 하나씩 읽어와서 처리할 때
    *   각 유저가 신고당한 횟수를 계산하기 위해 데이터를 순회할 때
    *   정지된 유저를 신고한 사람들에게 메일 카운트를 올려주기 위해 순회할 때
    *   최종 결과를 `id_list` 순서에 맞게 만들기 위해 `id_list`를 순회할 때

### 학습 순서 추천

1.  **기본 자료구조 이해:**
    *   **리스트(List)**와 **딕셔너리(Dictionary)**의 차이점과 기본적인 사용법(생성, 추가, 조회, 수정, 삭제)을 먼저 익히세요.
2.  **문자열 처리:**
    *   `split()` 메소드를 사용하여 문자열을 원하는 기준으로 나누는 방법을 연습하세요.
3.  **반복문과 조건문:**
    *   `for` 문을 사용하여 리스트와 딕셔너리를 순회하는 방법을 익히세요.
    *   `if` 문을 사용하여 특정 조건(예: 신고 횟수가 k 이상인지)을 확인하는 방법을 배우세요.
4.  **고급 자료구조:**
    *   **세트(Set)**의 특징(중복을 허용하지 않음)을 이해하고, 리스트와 어떻게 다른지, 언제 사용하면 좋은지 파악하세요.

```python
# defaultdict를 사용하기 위해 collections 모듈을 가져옵니다.
from collections import defaultdict

def solution(id_list, report, k):
    # 1. 초기 데이터 구조 준비
    # 각 유저가 받을 결과 메일 수를 저장할 딕셔너리 (defaultdict 사용)
    # int를 인자로 주면, 존재하지 않는 key에 접근 시 자동으로 0을 값으로 가짐
    answer_counts = defaultdict(int)
    
    # 각 유저가 신고당한 횟수를 저장할 딕셔너리
    reported_counts = defaultdict(int)
    
    # 각 유저를 누가 신고했는지 목록을 저장할 딕셔너리
    # list를 인자로 주면, 존재하지 않는 key에 접근 시 자동으로 빈 리스트([])를 값으로 가짐
    reporter_list = defaultdict(list)

    # 2. 중복 신고 제거
    # set을 사용하여 report 리스트의 중복된 값들을 제거합니다.
    # ["muzi frodo", "apeach frodo", "muzi frodo"] -> {"muzi frodo", "apeach frodo"}
    unique_report = set(report)

    # 3. 신고 기록 처리
    # 중복이 제거된 신고 기록을 하나씩 순회합니다.
    for r in unique_report:
        # split()을 사용하여 "신고한 유저"와 "신고당한 유저"를 분리합니다.
        reporter, reported = r.split()
        
        # 신고당한 유저의 신고 횟수를 1 증가시킵니다.
        # defaultdict(int)이므로 reported 키가 없어도 자동으로 0으로 생성 후 1을 더합니다.
        reported_counts[reported] += 1
        
        # 신고당한 유저를 Key로, 신고한 유저를 Value 리스트에 추가합니다.
        # defaultdict(list)이므로 reported 키가 없어도 자동으로 []로 생성 후 append합니다.
        reporter_list[reported].append(reporter)

    # 4. 이용 정지 유저 확인 및 메일 발송 횟수 계산
    # id_list를 순회하며 각 유저를 확인합니다.
    for user_id in id_list:
        # 만약 해당 유저가 k번 이상 신고당했다면 (이용 정지 대상이라면)
        if reported_counts[user_id] >= k:
            # 해당 유저를 신고한 모든 사람들을 찾습니다.
            for reporter in reporter_list[user_id]:
                # 신고한 사람(reporter)이 받을 메일 수를 1 증가시킵니다.
                answer_counts[reporter] += 1
    
    # 5. 최종 결과 반환
    # id_list 순서에 맞게 각 유저가 받을 메일 수를 리스트로 만들어 반환합니다.
    # 리스트 컴프리헨션을 사용하면 간결하게 작성할 수 있습니다.
    answer = [answer_counts[user_id] for user_id in id_list]
    
    return answer

# 예시 테스트
id_list = ["muzi", "frodo", "apeach", "neo"]
report = ["muzi frodo","apeach frodo","frodo neo","muzi neo","apeach muzi"]
k = 2
print(solution(id_list, report, k))  # 결과: [2, 1, 1, 0]

id_list2 = ["con", "ryan"]
report2 = ["ryan con", "ryan con", "ryan con", "ryan con"]
k2 = 3
print(solution(id_list2, report2, k2)) # 결과: [0, 0] (중복이 제거되어 con은 1번만 신고당함)
```

# ChatGpt
### from collections import defaultdict 
**위에 있는 항수를 사용하지 않고 처리하는 방법에 대해서 코드 설명을 부탁하여 나온 부분이 아래 코드이다**

```python
id_list = ["muzi", "frodo", "apeach", "neo"]
s_user = ["muzi frodo", "apeach frodo", "frodo neo", "muzi neo", "apeach muzi"]
k = 2

# 1. 신고 내역 저장 (중복 제거 포함)
report_dict = {}  # key: 신고자, value: set(신고한 사람들)

for report in s_user:
    reporter, reported = report.split()
    
    # key가 없으면 빈 set으로 초기화
    if reporter not in report_dict:
        report_dict[reporter] = set()
    
    report_dict[reporter].add(reported)

# 2. 신고당한 횟수 계산
reported_count = {}  # key: 피신고자, value: 횟수

for reported_users in report_dict.values():
    for reported in reported_users:
        if reported not in reported_count:
            reported_count[reported] = 0
        reported_count[reported] += 1

# 3. 정지된 유저 목록
banned_users = set()

for user, count in reported_count.items():
    if count >= k:
        banned_users.add(user)

# 4. 결과 메일 카운트 계산
result = []

for user in id_list:
    count = 0
    
    # 사용자가 누굴 신고했는지 확인
    if user in report_dict:
        for reported in report_dict[user]:
            if reported in banned_users:
                count += 1
    
    result.append(count)

print(result)  # [2, 1, 1, 0]
```

# 다른 사람 문제 풀이에서 가져온 부분

### 코드 라인별 상세 설명

```python
def solution(id_list, report, k):
```
- **설명:** `solution`이라는 이름의 함수를 정의하는 부분입니다. `id_list`(전체 유저 ID 목록), `report`(신고 기록 목록), `k`(정지 기준이 되는 신고 횟수)를 입력으로 받습니다.

```python
    answer = [0] * len(id_list)    
```
- **설명:** 최종 결과를 담을 `answer` 리스트를 생성하고 초기화합니다. `id_list`의 길이만큼 0으로 채워진 리스트를 만듭니다. 각 인덱스는 `id_list`의 유저 순서와 동일하며, 해당 유저가 받을 메일 수를 저장하는 용도입니다.
- **주의할 점: 리스트 안에 리스트가 있을 때**
```python
a = [[0] * 3] * 4
print(a) #[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```
겉으로는 괜찮아 보이지만,
내부 리스트들은 같은 객체를 참조하고 있어서,
하나만 수정해도 전부 바뀝니다:
```python
a[0][0] = 1
print(a) #[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]
```
이건 얕은 복사(shallow copy) 때문에 생기는 현상입니다.
→ 이런 경우에는 deepcopy를 쓰거나 리스트 컴프리헨션을 사용하세요:
```python
a = [[0] * 3 for _ in range(4)]
```
---
```python
    reports = {x : 0 for x in id_list}
```
- **설명:** 각 유저가 신고당한 횟수를 저장할 `reports` 딕셔너리(사전)를 만듭니다. `id_list`의 모든 유저 ID를 키(key)로, 신고당한 횟수를 값(value)으로 가지며, 모든 값을 0으로 초기화합니다.

```python
    for r in set(report):
```
- **설명:** 신고 기록을 처리하기 위한 첫 번째 반복문입니다. `set(report)`를 사용하여 `report` 리스트에 있는 중복된 신고(예: 한 유저가 동일한 유저를 여러 번 신고한 경우)를 모두 제거하고, 유일한 신고 기록에 대해서만 반복을 수행합니다.

```python
        reports[r.split()[1]] += 1
```
- **설명:** `r`은 "신고한유저 신고당한유저" 형태의 문자열입니다. `r.split()`는 이 문자열을 공백 기준으로 나눠 `['신고한유저', '신고당한유저']` 형태의 리스트로 만듭니다. `[1]`은 이 리스트의 두 번째 요소, 즉 '신고당한 유저'의 ID를 가리킵니다. 이 ID를 키로 사용하여 `reports` 딕셔너리의 값을 1 증가시킵니다. 이 반복문이 끝나면 각 유저가 총 몇 번의 (중복을 제외한) 신고를 당했는지 집계됩니다.

```python
    for r in set(report):
```
- **설명:** 처리 결과를 계산하기 위한 두 번째 반복문입니다. 다시 한번 중복을 제거한 유일한 신고 기록들을 하나씩 확인합니다.

```python
        if reports[r.split()[1]] >= k:
```
- **설명:** 현재 확인 중인 신고 기록(`r`)에서 '신고당한 유저'(`r.split()[1]`)가 `reports` 딕셔너리에서 `k`번 이상 신고되었는지 확인합니다. 즉, 해당 유저가 이용 정지 대상인지 검사하는 조건문입니다.

```python
            answer[id_list.index(r.split()[0])] += 1
```
- **설명:** 위 `if` 조건이 참일 경우(신고당한 유저가 정지 대상일 경우) 실행됩니다.
  - `r.split()[0]`: 신고를 한 유저의 ID를 가져옵니다.
  - `id_list.index(...)`: 신고한 유저의 ID가 원래 `id_list`에서 몇 번째 위치(인덱스)에 있는지 찾습니다.
  - `answer[...] += 1`: `answer` 리스트에서 위에서 찾은 인덱스에 해당하는 값을 1 증가시킵니다. 이는 정지된 유저를 신고했던 사람에게 "처리 결과 메일"을 보내는 횟수를 1 늘리는 것과 같습니다.

```python
    return answer
```
- **설명:** 모든 계산이 끝난 후, 각 유저가 받을 메일 횟수가 순서대로 담긴 `answer` 리스트를 최종적으로 반환합니다.
```python
def solution(id_list, report, k):
    answer = [0] * len(id_list)    
    reports = {x : 0 for x in id_list}

    for r in set(report):
        reports[r.split()[1]] += 1

    for r in set(report):
        if reports[r.split()[1]] >= k:
            answer[id_list.index(r.split()[0])] += 1

    return answer
```

# 위 코드에 성능 저하 부분 해결

기존 코드는 직관적이지만, `report`의 길이와 `id_list`의 길이가 길어질 경우 성능이 크게 저하될 수 있는 부분을 포함하고 있습니다.

결론부터 말씀드리면, **반복문 안에서 `list.index()`를 사용하는 것**과 **`set(report)`를 두 번 순회하는 것**이 가장 큰 성능 저하의 원인입니다. 이를 개선한 코드는 다음과 같습니다.

### 개선된 코드

```python
from collections import defaultdict

def solution(id_list, report, k):
    # 1. 초기화 및 효율적인 조회를 위한 자료구조 생성
    answer = [0] * len(id_list)
    # 각 id의 인덱스를 O(1) 시간 복잡도로 찾기 위한 딕셔너리
    id_idx = {id: i for i, id in enumerate(id_list)}
    
    # 유저별 신고당한 횟수를 저장할 딕셔너리
    reported_counts = defaultdict(int)
    # 각 유저를 누가 신고했는지 저장할 딕셔너리 {신고당한 유저: {신고한 유저1, 신고한 유저2, ...}}
    reporter_map = defaultdict(set)

    # 2. 신고 기록을 한 번만 순회하며 필요한 정보 저장 (O(M), M: report의 길이)
    for r in set(report):
        reporter, reported = r.split()
        
        # 동일한 유저가 동일한 유저를 여러 번 신고하는 것은 set으로 이미 걸러졌지만,
        # 코드 구조상 reporter_map에 추가하는 것이 신고 관계를 명확히 함
        reporter_map[reported].add(reporter)

    # 3. 정지될 유저를 결정하고, 메일 발송 횟수 계산 (O(N), N: id_list의 길이)
    for reported_id, reporters in reporter_map.items():
        # 신고한 사람의 수가 k 이상이면
        if len(reporters) >= k:
            # 이 유저를 신고한 모든 사람들에게 메일 발송 횟수 +1
            for reporter_id in reporters:
                answer[id_idx[reporter_id]] += 1
                
    return answer
```

---

### 무엇이, 왜 개선되었는가?

#### 1. 기존 코드의 비효율적인 부분

1.  **`list.index()`의 반복 사용 (가장 큰 문제)**
    *   `answer[id_list.index(r.split()[0])] += 1`
    *   `list.index(value)`는 리스트의 처음부터 `value`를 찾을 때까지 순차적으로 탐색합니다. 리스트의 길이가 N일 때 평균적으로 O(N)의 시간 복잡도를 가집니다.
    *   이 코드가 `for r in set(report):` 반복문 안에 있으므로, 최악의 경우 `(고유 신고 건수) * (유저 수)` 만큼의 연산이 필요하게 되어 시간 초과를 유발합니다.

2.  **불필요한 반복**
    *   `set(report)`를 두 번 순회합니다. 첫 번째는 신고 횟수를 세기 위해, 두 번째는 메일 발송 대상을 찾기 위해 순회합니다. 데이터가 많아지면 이 또한 비효율적일 수 있습니다.

#### 2. 개선된 코드의 핵심 아이디어

1.  **`id -> index` 딕셔너리(해시맵) 활용**
    *   `id_idx = {id: i for i, id in enumerate(id_list)}`
    *   코드를 시작할 때 미리 각 `id`가 `id_list`의 몇 번째 인덱스에 있는지 딕셔너리로 만들어 둡니다.
    *   딕셔너리에서 값을 찾는 것은 평균 O(1)의 시간 복잡도를 가집니다.
    *   따라서 반복문 안에서 `id_list.index()`를 쓰는 대신 `id_idx[reporter_id]`를 사용하여 매우 빠르게 해당 유저의 인덱스를 찾을 수 있습니다.

2.  **효율적인 자료구조 사용 및 로직 변경**
    *   `defaultdict(set)`을 사용하여 `{'신고당한 유저': {신고한 유저들}}` 형태의 맵을 만듭니다. 이렇게 하면 신고 관계를 한 번의 순회로 모두 정리할 수 있습니다.
    *   기존 코드처럼 신고 횟수를 따로 세고, 다시 신고 기록을 순회하는 방식이 아닙니다.
    *   신고 관계 맵(`reporter_map`)을 만든 후, 이 맵을 순회하며 `len(reporters)`가 `k` 이상인 경우에만 해당 `reporters`들에게 메일 발송 횟수를 더해줍니다.
    *   이 방식은 전체 유저(`id_list`)를 기준으로 순회하므로, 신고 건수가 아무리 많아도 루프의 수가 유저 수에 비례하여 훨씬 효율적입니다.

### 성능 비교

| 구분 | 기존 코드의 시간 복잡도 | 개선된 코드의 시간 복잡도 |
| :--- | :--- | :--- |
| **핵심 로직** | O(M * N) <br/> (M: 고유 신고 수, N: 유저 수) | O(M + N) <br/> (M: 고유 신고 수, N: 유저 수) |
| **설명** | `set(report)`를 순회(M)하면서 매번 `id_list.index()`를 호출(N)하는 것이 병목 지점입니다. | 신고 기록 처리(M)와 메일 발송 처리(N)가 분리되어 있어 훨씬 빠릅니다. |

결론적으로, **알고리즘 문제 해결에서 반복문 내의 선형 탐색(`list.index`)은 거의 항상 피해야 할 패턴**이며, 이를 **해시맵(딕셔너리)을 이용한 O(1) 조회로 바꾸는 것**이 성능 개선의 핵심입니다.
```python 
from collections import defaultdict

def solution(id_list, report, k):
    answer = [0] * len(id_list)
    id_idx = {id: i for i, id in enumerate(id_list)}
    
    reported_counts = defaultdict(int)
    reporter_map = defaultdict(set)

    for r in set(report):
        reporter, reported = r.split()
        reporter_map[reported].add(reporter)
    for reported_id, reporters in reporter_map.items():
        if len(reporters) >= k:
            for reporter_id in reporters:
                answer[id_idx[reporter_id]] += 1
                
    return answer
```
# from collections import defaultdict 내용
파이썬에서 데이터를 다룰 때 정말 유용하게 사용되는 기능이라 알아두시면 코드가 훨씬 간결하고 효율적으로 변합니다.

### `collections.defaultdict` 란?

`defaultdict`는 파이썬의 내장 `collections` 모듈에 포함된 클래스로, **일반 딕셔너리(`dict`)의 하위 클래스**입니다.

가장 큰 특징은 **딕셔너리에 존재하지 않는 키(key)에 접근하려고 할 때, `KeyError`를 발생시키는 대신 지정된 '기본값(default value)'을 생성하여 반환**해준다는 점입니다.

---

### 왜 사용할까요? (일반 딕셔너리의 불편한 점)

일반 딕셔너리에서 존재하지 않는 키에 값을 추가하거나 수정하려고 하면 다음과 같은 코드를 작성해야 합니다.

```python
# 예시: 단어의 개수를 세는 경우
word_counts = {}
text = "apple banana apple orange banana apple"

for word in text.split():
    # 1. if-else 문으로 키 존재 여부 확인
    if word in word_counts:
        word_counts[word] += 1
    else:
        word_counts[word] = 1

# 또는 2. try-except 구문 사용
# for word in text.split():
#     try:
#         word_counts[word] += 1
#     except KeyError:
#         word_counts[word] = 1

print(word_counts)
# 출력: {'apple': 3, 'banana': 2, 'orange': 1}
```

이렇게 매번 키가 존재하는지 확인하는 코드는 번거롭고 가독성을 떨어뜨립니다. `defaultdict`는 바로 이 문제를 해결해 줍니다.

---

### 어떻게 동작하나요?

`defaultdict`를 생성할 때는 **"기본값을 만들어낼 함수"**를 인자로 전달해야 합니다. 이 함수를 **`default_factory`**라고 부릅니다.

`defaultdict`는 존재하지 않는 키에 접근하면, 이 `default_factory` 함수를 호출하여 그 반환값으로 해당 키의 기본값을 설정하고, 그 값을 반환합니다.

---

### 주요 사용 예시

#### 1. 항목의 개수 세기: `defaultdict(int)`

*   `default_factory`로 `int`를 사용하면, `int()`가 호출되어 기본값으로 `0`이 생성됩니다.

```python
from collections import defaultdict

# int를 기본값 생성 함수로 지정
word_counts = defaultdict(int) 
text = "apple banana apple orange banana apple"

for word in text.split():
    # 'apple'이 처음 나올 때 word_counts에 'apple'이 없으므로,
    # int()를 호출하여 0을 생성하고, 그 값에 1을 더함.
    word_counts[word] += 1

print(word_counts)
# 출력: defaultdict(<class 'int'>, {'apple': 3, 'banana': 2, 'orange': 1})
```
`if`문 없이 코드가 훨씬 간결해진 것을 볼 수 있습니다.

#### 2. 항목 그룹화하기: `defaultdict(list)`

*   `default_factory`로 `list`를 사용하면, `list()`가 호출되어 기본값으로 빈 리스트 `[]`가 생성됩니다.

```python
from collections import defaultdict

# list를 기본값 생성 함수로 지정
name_list = [('John', 'New York'), ('Jane', 'London'), ('John', 'Tokyo'), ('Mike', 'New York')]
city_map = defaultdict(list)

for name, city in name_list:
    # city_map에 'New York'이 처음 나올 때, list()를 호출하여 빈 리스트 []를 생성하고,
    # 그 리스트에 'John'을 추가함.
    city_map[city].append(name)

print(city_map)
# 출력: defaultdict(<class 'list'>, {'New York': ['John', 'Mike'], 'London': ['Jane'], 'Tokyo': ['John']})
```

#### 3. 중복 없는 항목 그룹화하기: `defaultdict(set)`

*   `default_factory`로 `set`을 사용하면, `set()`이 호출되어 기본값으로 빈 집합 `set()`이 생성됩니다.
*   이것이 바로 **이전 코드 예시(`신고 결과 받기`)에서 사용된 방식**입니다.

```python
from collections import defaultdict

# set을 기본값 생성 함수로 지정
reporter_map = defaultdict(set)

# set(report)의 결과가 ['a b', 'a c', 'b c', 'c a'] 라고 가정
reports = ['a b', 'a c', 'b c', 'c a']

for r in reports:
    reporter, reported = r.split()
    # reporter_map에 'b'가 처음 나올 때, set()을 호출하여 빈 집합을 생성하고,
    # 그 집합에 'a'를 추가함.
    reporter_map[reported].add(reporter)

print(reporter_map)
# 출력: defaultdict(<class 'set'>, {'b': {'a'}, 'c': {'a', 'b'}, 'a': {'c'}})
```
이 방식을 사용했기 때문에, `if reported in reporter_map:` 과 같은 확인 절차 없이 바로 `reporter_map[reported].add(reporter)`를 사용할 수 있었던 것입니다.

---

### 일반 딕셔너리(dict)와의 차이점 요약

| 구분 | 일반 딕셔너리 (dict) | `defaultdict` |
| :--- | :--- | :--- |
| **키가 없을 때 접근** | `KeyError` 발생 | `default_factory`로 지정된 기본값을 생성하고 반환 |
| **초기화** | `d = {}` | `d = defaultdict(int)` 와 같이 기본값 생성 함수 필요 |
| **주요 용도** | 일반적인 키-값 저장 | 값의 초기화가 반복적으로 필요한 경우 (카운팅, 그룹핑 등) |

**결론적으로 `defaultdict`는 딕셔너리의 특정 키에 대한 값을 초기화하는 반복적인 코드를 대폭 줄여주어, 코드를 더 깔끔하고 가독성 높게 만들어주는 매우 유용한 자료구조입니다.**

# 실제 처리 코드
### 실제 코드를 사용하여 처리된 부분은 실행 시간이 문제가 있음
```python
def solution(id_list, report, k):
    report_dict = {}
    for r in report:
        reporter, reported = r.split()
        
        if reporter not in report_dict:
            report_dict[reporter] = set()
        
        report_dict[reporter].add(reported)
    
    report_count = {}
    for ru in report_dict.values():
        for rt in ru:
            if rt not in report_count:
                report_count[rt] = 0
            report_count[rt] += 1

    ban_users = set()
    
    for u, c in report_count.items():
        if c >= k:
            ban_users.add(u) 

    answer = []
    for user in id_list:
        count = 0

        if user in report_dict:
            for reported in report_dict[user]:
                if reported in ban_users:
                    count += 1
        answer.append(count)
    return answer
```